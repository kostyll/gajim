%%
headers
#include <Python.h>
#include "pygobject.h"
#include <gst/gstelement.h>
#include <farsight/farsight.h>
#include <farsight/farsight-transport.h>

/* functions to put data into dict */
inline static void insert_long_into_dict(PyObject* dict, char* key, long value) {
	PyObject* item=PyInt_FromLong(value);
	PyDict_SetItemString(dict, key, item);
	Py_DECREF(item);
}

inline static void insert_str_into_dict(PyObject* dict, char* key, const char* value) {
	if (!value) return;
	PyObject* item=PyString_FromString(value);
	PyDict_SetItemString(dict, key, item);
	Py_DECREF(item);
}

inline static void insert_double_into_dict(PyObject* dict, char* key, double value) {
	PyObject* item=PyFloat_FromDouble(value);
	PyDict_SetItemString(dict, key, item);
	Py_DECREF(item);
}

static PyObject* farsight_transport_info_to_dict(FarsightTransportInfo* fti) {
	PyObject* dict = PyDict_New();

	insert_str_into_dict	(dict, "candidate_id",	fti->candidate_id);
	insert_long_into_dict	(dict, "component",	fti->component);
	insert_str_into_dict	(dict, "ip",		fti->ip);
	insert_long_into_dict	(dict, "port",		fti->port);
	insert_long_into_dict	(dict, "proto",		fti->proto);
	insert_str_into_dict	(dict, "proto_subtype",	fti->proto_subtype);
	insert_str_into_dict	(dict, "proto_profile",	fti->proto_profile);
	insert_double_into_dict	(dict, "preference",	fti->preference);
	insert_long_into_dict	(dict, "type",		fti->type);
	insert_str_into_dict	(dict, "username",	fti->username);
	insert_str_into_dict	(dict, "password",	fti->password);

	return dict;
}

static PyObject* farsight_codec_to_dict(FarsightCodec* fc) {
	PyObject* dict = PyDict_New();

	/* these two are required */
	insert_long_into_dict(dict, "id", fc->id);
	insert_str_into_dict(dict, "encoding_name", fc->encoding_name);
	insert_long_into_dict(dict, "media_type", fc->media_type);

	/* next are optional */
	if (fc->clock_rate)	insert_long_into_dict(dict, "clock_rate", fc->clock_rate);
	if (fc->channels)	insert_long_into_dict(dict, "channels", fc->channels);

	if (fc->optional_params) {
		PyObject* params = PyDict_New();
		GList* list;

		for(list=fc->optional_params; list; list=g_list_next(list)) {
			FarsightCodecParameter *fcp=list->data;
			insert_str_into_dict(params, fcp->name, fcp->value);
		}

		PyDict_SetItemString(dict, "params", params);
		Py_DECREF(params);
	}

	return dict;
}

/* functions to get data from dict */
/* next three functions might raise an error */
inline static long get_long_from_dict(PyObject* dict, char* key) {
	PyObject* pyint=PyMapping_GetItemString(dict, key);
	return(pyint?PyInt_AsLong(pyint):0);
}

inline static char* get_str_from_dict(PyObject* dict, char* key) {
	PyObject* str=PyMapping_GetItemString(dict, key);
	return(str?PyString_AsString(str):NULL);
}

inline static double get_double_from_dict(PyObject* dict, char* key) {
	PyObject* pyfloat=PyMapping_GetItemString(dict, key);
	return(pyfloat?PyFloat_AsDouble(pyfloat):0.0);
}

/* may raise an exception */
static void dict_to_farsight_transport_info(PyObject* dict, FarsightTransportInfo* fti) {
	if (!dict) return;

	/* required */
	fti->candidate_id	= get_str_from_dict(dict, "candidate_id");
	fti->component		= get_long_from_dict(dict, "component");
	fti->ip			= get_str_from_dict(dict, "ip");
	fti->port		= get_long_from_dict(dict, "port");
	fti->proto		= get_long_from_dict(dict, "proto");
	fti->proto_subtype	= get_str_from_dict(dict, "proto_subtype");
	fti->proto_profile	= get_str_from_dict(dict, "proto_profile");
	fti->preference		= get_double_from_dict(dict, "preference");
	fti->type		= get_long_from_dict(dict, "type");

	if (PyErr_Occurred()) return;

	/* optional */
	fti->username		= get_str_from_dict(dict, "username");
	fti->password		= get_str_from_dict(dict, "password");

	PyErr_Clear();
}

/* GArray must be freed if not NULL;
   may raise an exception */
static void dict_to_farsight_codec(PyObject* dict, FarsightCodec* fc, GArray** fcp) {
	GArray* array=*fcp;

	if (!dict) return;

	/* required data */
	fc->id			= get_long_from_dict(dict, "id");
	fc->encoding_name	= get_str_from_dict(dict, "encoding_name");
	fc->media_type		= 0;
	fc->clock_rate		= 0;
	fc->channels		= 0;
	fc->optional_params	= NULL;

	if (PyErr_Occurred()) return;

	/* optional data */
	fc->media_type		= get_long_from_dict(dict, "media_type");
	fc->clock_rate		= get_long_from_dict(dict, "clock_rate");
	fc->channels		= get_long_from_dict(dict, "channels");

	if (PyMapping_HasKeyString(dict, "params")) {
		PyObject* params = PyMapping_GetItemString(dict, "params");
		if (PyDict_Check(params)) {
			PyObject *key, *value;
			int pos=0;
			GList* list=NULL;
			int i=0;

			if (!array)
				array = g_array_new(FALSE, FALSE, sizeof(FarsightCodecParameter));

			while (PyDict_Next(params, &pos, &key, &value)) {
				if (PyString_Check(key) && PyString_Check(value)) {
					FarsightCodecParameter fcp;
					fcp.name = PyString_AsString(key);
					fcp.value= PyString_AsString(value);
					g_array_append_val(array, fcp);
					list=g_list_prepend(list,
						&g_array_index(array, FarsightCodecParameter, i++));
				} else {
					/* this is not a string? not good... */
					puts("keys and values must be strings here!");
				}
			}

			fc->optional_params = list;
		} else {
			/* this is not a dictionary? fail miserably... */
			puts("params must be a dictionary!");
		}
	}

	PyErr_Clear();

	*fcp = array;
}

%%
modulename farsight
%%
import gtk.Plug as PyGtkPlug_Type
import gobject.GObject as PyGObject_Type
import gobject.GType as PyGTypeModule_Type
import gst.Element as PyGstElement_Type
import gst.Pad as PyGstPad_Type
%%
ignore-glob
  *_get_type
%%
override farsight_session_list_supported_codecs noargs
static PyObject* _wrap_farsight_session_list_supported_codecs(PyGObject *self)
{
	const GList *list, *tmp;
	PyObject* ret;

	list=farsight_session_list_supported_codecs(FARSIGHT_SESSION(self->obj));

	ret=PyList_New(0);
	for (tmp=list; tmp!=NULL; tmp=tmp->next) {
		FarsightCodec *codec = tmp->data;
		PyObject *item = farsight_codec_to_dict(codec);

		PyList_Append(ret, item);
		Py_DECREF(item);
	}
	// g_list_free(list); (a const list, we don't free it?)
	return ret;
}
%%
override farsight_stream_get_local_codecs noargs
static PyObject* _wrap_farsight_stream_get_local_codecs(PyGObject *self)
{
	const GList *list, *tmp;
	PyObject* ret;

	list=farsight_stream_get_local_codecs(FARSIGHT_STREAM(self->obj));


	ret=PyList_New(0);
	for (tmp=list; tmp!=NULL; tmp=g_list_next(tmp)) {
		FarsightCodec *codec = tmp->data;
		PyObject *item = farsight_codec_to_dict(codec);

		PyList_Append(ret, item);
		Py_DECREF(item);
	}
	// g_list_free(list); (a const list, we don't free it?)
	return ret;
}
%%
override farsight_stream_get_native_candidate kwargs
static PyObject* _wrap_farsight_stream_get_native_candidate(PyGObject *self,
                                                            PyObject *args,
							    PyObject *kwargs)
{
	static char* kwlist[] = {"candidate_id", NULL};
	char* candidate_id;
	GList* list, *tmp;
	FarsightTransportInfo* data;
	PyObject* ret;
	PyObject* item;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s", kwlist, &candidate_id))
		return NULL;

	list = farsight_stream_get_native_candidate(FARSIGHT_STREAM(self->obj), candidate_id);

	ret = PyList_New(0);
	for(tmp=list;list;list=g_list_next(list)) {
		FarsightTransportInfo *fti = tmp->data;
		PyObject *item = farsight_transport_info_to_dict(fti);

		PyList_Append(ret, item);
		Py_DECREF(item);
	}

	g_list_free(list);

	return ret;
}
%%
override farsight_stream_get_native_candidate_list noargs
static PyObject* _wrap_farsight_stream_get_native_candidate_list(PyGObject *self)
{
	const GList *list, *tmp;
	PyObject* ret;

	list=farsight_stream_get_native_candidate_list(FARSIGHT_STREAM(self->obj));

	ret = PyList_New(0);
	for(tmp=list;list;list=g_list_next(list)) {
		FarsightTransportInfo *fti = tmp->data;
		PyObject *item = farsight_transport_info_to_dict(fti);

		PyList_Append(ret, item);
		Py_DECREF(item);
	}

	return ret;
}
%%
override farsight_stream_set_codec_preference_list kwargs
static PyObject* _wrap_farsight_stream_set_codec_preference_list(PyGObject *self,
                                                                 PyObject *args,
								 PyObject *kwargs)
{
	/* one could try to unpack tuples right into the array */
	static char *kwlist[] = {"codec_pref", NULL};
	PyObject* list;
	GArray* codec_pref_array;
	FarsightCodecPreference codec_pref;
	int i;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist, &list))
		return NULL;
	
	codec_pref_array = g_array_sized_new(FALSE, FALSE,
		sizeof(FarsightCodecPreference), PySequence_Size(list));

	for(i=0; i<PySequence_Size(list); i++) {
		PyArg_ParseTuple(PySequence_GetItem(list, i), "si",
			&codec_pref.encoding_name,
			&codec_pref.clock_rate);
		g_array_append_val(codec_pref_array, codec_pref);
	}

	farsight_stream_set_codec_preference_list(FARSIGHT_STREAM(self->obj),
		(const GArray*) codec_pref_array);

	g_array_free(codec_pref_array, FALSE);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override farsight_stream_set_remote_candidate_list kwargs
static PyObject* _wrap_farsight_stream_set_remote_candidate_list(PyGObject *self,
                                                                 PyObject *args,
								 PyObject *kwargs)
{
	static char* kwlist[] = {"remote_candidates", NULL};
	PyObject* list;
	GArray* candidate_array;
	GList* candidate_list=NULL;
	int i, listsize;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist, &list))
		return NULL;

	candidate_array=g_array_sized_new(FALSE, TRUE,
		sizeof(FarsightTransportInfo), PySequence_Size(list));

	listsize=PySequence_Size(list);
	for(i=0;i<listsize;i++) {
		FarsightTransportInfo fti;

		dict_to_farsight_transport_info(PySequence_GetItem(list, listsize-i-1), &fti);

		g_array_append_val(candidate_array, fti);

		candidate_list = g_list_prepend(candidate_list,
			&g_array_index(candidate_array, FarsightTransportInfo, i));
	}

	if(!PyErr_Occurred()) {
		farsight_stream_set_remote_candidate_list(FARSIGHT_STREAM(self->obj), candidate_list);
	}

	g_array_free(candidate_array, FALSE);
	g_list_free(candidate_list);

	if(!PyErr_Occurred()) {
		Py_INCREF(Py_None);
		return Py_None;
	} else {
		return NULL;
	}
}
%%
override farsight_stream_set_remote_codecs kwargs
static PyObject* _wrap_farsight_stream_set_remote_codecs(PyGObject *self,
                                                         PyObject *args,
							 PyObject *kwargs)
{
	static char* kwlist[] = {"codecs", NULL};
	PyObject* list, * item;
	GArray* codecs_array;
	GArray* fcp_array=NULL;
	GList* codecs_list=NULL;
	int i, listsize;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist, &list))
		return NULL;

	codecs_array=g_array_sized_new(FALSE, TRUE,
		sizeof(FarsightCodec), PySequence_Size(list));

	listsize=PySequence_Size(list);
	for(i=0;i<listsize;i++) {
		FarsightCodec fc;

		dict_to_farsight_codec(PySequence_GetItem(list, listsize-i-1), &fc, &fcp_array);

		g_array_append_val(codecs_array, fc);
		codecs_list = g_list_prepend(codecs_list,
			&g_array_index(codecs_array, FarsightCodec, i));
	}

	if (!PyErr_Occurred()) {
		farsight_stream_set_remote_codecs(FARSIGHT_STREAM(self->obj), codecs_list);
	}

	g_array_free(fcp_array, FALSE);
	g_array_free(codecs_array, FALSE);
	g_list_free(codecs_list);

	if (!PyErr_Occurred()) {
		Py_INCREF(Py_None);
		return Py_None;
	} else {
		return NULL;
	}
}
%%
override farsight_stream_add_remote_candidate kwargs
static PyObject* _wrap_farsight_stream_add_remote_candidate(PyGObject *self,
                                                            PyObject *args,
							    PyObject *kwargs)
{
	static char* kwlist[] = {"remote_candidate", NULL};
	PyObject* list;
	GArray* candidate_array;
	GList* candidate_list=NULL;
	int i, listsize;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist, &list))
		return NULL;

	candidate_array=g_array_sized_new(FALSE, TRUE,
		sizeof(FarsightTransportInfo), PySequence_Size(list));

	listsize=PySequence_Size(list);
	for(i=0;i<listsize;i++) {
		FarsightTransportInfo fti;

		dict_to_farsight_transport_info(PySequence_GetItem(list, listsize-i-1), &fti);

		g_array_append_val(candidate_array, fti);

		candidate_list = g_list_prepend(candidate_list,
			&g_array_index(candidate_array, FarsightTransportInfo, i));
	}

	GList* t;
	for(t=candidate_list;t;t=g_list_next(t)) {
		FarsightTransportInfo* info=t->data;
		printf ("Remote transport candidate: %s %d %s %s %s %d pref %f",
		        info->candidate_id, info->component,
		        (info->proto == FARSIGHT_NETWORK_PROTOCOL_TCP) ? "TCP" : "UDP",
		        info->proto_subtype, info->ip, info->port, (double) info->preference);
	}

	if(!PyErr_Occurred()) {
		farsight_stream_add_remote_candidate(FARSIGHT_STREAM(self->obj), candidate_list);
	}

	g_array_free(candidate_array, FALSE);
	g_list_free(candidate_list);

	if(!PyErr_Occurred()) {
		Py_INCREF(Py_None);
		return Py_None;
	} else {
		return NULL;
	}
}
